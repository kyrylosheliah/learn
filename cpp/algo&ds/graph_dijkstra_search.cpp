//Вариант 6 - дийкстра
//
//Компания по перевозке пассажиров осуществляет поездки в 10 населенных пунктов района.
//На рис. 8.6.6 представлены маршруты перевозки пассажиров с указанием расстояния в километрах.
//Определить кратчайшие пути между узлом 1 и всеми остальными узлами ориентированного графа.

#include <iostream>
using namespace std;

const int infinity = INT_MAX;
const int SIZE = 10;

void main()
{
	setlocale(LC_ALL, "");

	int a[SIZE][SIZE] = { { 0, 5, 10, 0, 0, 0, 0, 0, 0, 0},
						  { 0, 0, 0, 15, 12, 22, 0, 0, 0, 0},
						  { 0, 8, 0, 0, 6, 7, 0, 0, 0, 0},
						  { 0, 0, 0, 0, 0, 0, 11, 0, 30, 0},
						  { 0, 0, 0, 17, 0, 0, 0, 9, 0, 0},
						  { 0, 0, 0, 0, 8, 0, 0, 18, 0, 35},
						  { 0, 0, 0, 0, 20, 0, 0, 18, 25, 0},
						  { 0, 0, 0, 0, 0, 0, 0, 0, 8, 0},
						  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 12},
						  { 0, 0, 0, 0, 0, 0, 0, 14, 11, 0} };	// матрица связей
	int d[SIZE];	// минимальное расстояние
	int v[SIZE];	// посещенные вершины
	int temp, minindex, min;
	int begin_index = 0;
	

	for (int i = 0; i < SIZE; i++)	// Вывод матрицы связей
	{
		for (int j = 0; j < SIZE; j++)
		{
			cout << a[i][j] << "\t";
		}
		cout << "\n";
	}

	//Инициализация вершин и расстояний
	for (int i = 0; i < SIZE; i++)
	{
		d[i] = infinity;
		v[i] = 1;
	}

	d[begin_index] = 0;

	do 
	{
		minindex = infinity;
		min = infinity;
		for (int i = 0; i < SIZE; i++)
		{
			if ((v[i] == 1) && (d[i] < min))	// Если вершину ещё не обошли и вес меньше min
			{									// Переприсваиваем значения
				min = d[i];
				minindex = i;
			}
		}
		// Добавляем найденный минимальный вес
		// к текущему весу вершины
		// и сравниваем с текущим минимальным весом вершины
		if (minindex != infinity)
		{
			for (int i = 0; i < SIZE; i++)
			{
				if (a[minindex][i] > 0)
				{
					temp = min + a[minindex][i];
					if (temp < d[i])
					{
						d[i] = temp;
					}
				}
			}
			v[minindex] = 0;
		}
	} while (minindex < infinity);

	// Вывод кратчайших расстояний до вершин
	cout << "\nКратчайшие расстояния до вершин: \n";
	for (int i = 0; i < SIZE; i++)
	{
		cout << d[i] << " ";
	}

	// Восстановление пути
	int ver[SIZE];			// массив посещенных вершин
	int end = SIZE - 1;		// индекс конечной вершины
	ver[0] = end + 1;		// начальный элемент - конечная вершина
	int k = 1;				// индекс предыдущей вершины
	int weight = d[end];	// вес конечной вершины

	while (end != begin_index) // пока не дошли до начальной вершины
	{
		for (int i = 0; i < SIZE; i++) // просматриваем все вершины
			if (a[i][end] != 0)   // если связь есть
			{
				int temp = weight - a[i][end]; // определяем вес пути из предыдущей вершины
				if (temp == d[i]) // если вес совпал с рассчитанным
				{                 // значит из этой вершины и был переход
					weight = temp; // сохраняем новый вес
					end = i;       // сохраняем предыдущую вершину
					ver[k] = i + 1; // и записываем ее в массив
					k++;
				}
			}
	}

	cout << "\nКратчайший путь\n";	// Вывод пути (начальная вершина оказалась в конце массива из k элементов)
	for (int i = k - 1; i >= 0; i--)
	{
		cout << ver[i] << " ";
	}

	system("pause");
}