//Вариант 6 - Флойд
//
//Компания грузоперевозок осуществляет доставку товаров в 7 городов страны.
//Сеть доставки показана на рис.8.6.21.
//Расстояния между узлами графа выражены в тысячах километров.
//Определить кратчайшие пути между узлами графа.

#include <iostream>
using namespace std;

const int infinity = INT_MAX;
const int SIZE = 7;

int massfloyd[SIZE][SIZE] = { { 0, 800, 300, 650, 0, 0, 0 },
							  { 800, 0, 0, 900, 500, 0, 0 },
							  { 300, 0, 0, 850, 0, 950, 0 },
							  { 650, 900, 850, 0, 700, 600, 0 },
							  { 0, 500, 0, 700, 0, 500, 800 },
							  { 0, 0, 950, 600, 500, 0, 900 },
							  { 0, 0, 0, 0, 800, 900, 0 } };		// Матрица весов ребер, будет перезаписана алгоритмом
int mass[SIZE][SIZE] = { { 0, 800, 300, 650, 0, 0, 0 },
						 { 800, 0, 0, 900, 500, 0, 0 },
						 { 300, 0, 0, 850, 0, 950, 0 },
						 { 650, 900, 850, 0, 700, 600, 0 },
						 { 0, 500, 0, 700, 0, 500, 800 },
						 { 0, 0, 950, 600, 500, 0, 900 },
						 { 0, 0, 0, 0, 800, 900, 0 } };		// Матрица весов ребер


void floyd(int D[][SIZE])		//алгоритм Флойда-Уоршелла
{
	for (int i = 0; i < SIZE; i++)
	{
		D[i][i] = 0;
	}
	for (int k = 0; k < SIZE; k++)
	{
		for (int i = 0; i < SIZE; i++)
		{
			for (int j = 0; j < SIZE; j++)
			{
				if (D[i][k] && D[k][j] && i != j)
				{
					if (D[i][k] + D[k][j] < D[i][j] || D[i][j] == 0)
					{
						D[i][j] = D[i][k] + D[k][j];
					}
				}
			}
		}
	}

	cout << "\nМатрица по алгоритму Флойда\n";
	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE; j++) cout << D[i][j] << "\t";
		cout << endl;
	}

	// Восстановление пути
	int ver[SIZE];			// Массив восстановленного пути наоборот
	int end = SIZE - 1;		// индекс конечной вершины
	ver[0] = SIZE;
	int k = 1;				// индекс элемента, с которого начинается запись в ver[]
	int weight = D[0][end];	// полученный ранее минимальный вес

	while (end != 0) // пока не дошли до начальной вершины
	{
		for (int i = 0; i < SIZE; i++) // просматриваем все вершины
			if (mass[i][end])   // если  есть связь
			{
				int temp = weight - mass[i][end];	// определяем вес пути из предыдущей вершины
				if (temp == D[0][i])					// если вес совпал с рассчитанным
				{										// значит из этой вершины и был переход
					weight = temp;						// сохраняем новый вес
					end = i;							// сохраняем предыдущую вершину
					ver[k] = i + 1;						// и записываем ее в массив
					k++;
				}
			}
	}

	cout << "\nКратчайший путь: ";
	for (int i = k - 1; i >= 0; i--)
	{
		cout << "<" << ver[i] << "> - ";
	}
}

int main()
{
	setlocale(LC_ALL, "");

	cout << "Количество вершин в графе > " << SIZE << "\nМатрица весов ребер:\n";
	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			cout << mass[i][j] << "\t";
		}
		cout << "\n";
	}

	floyd(massfloyd);	//расчет матрицы Флойда-Уоршелла и восстановление путей от вершины 1 до остальных

	system("pause>>void");
}